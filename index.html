<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universe Guidebook</title>
    <meta name="description" content="ゼロから学ぶ宇宙の仕組み。太陽系から最新の宇宙論まで">
    
    <!-- Tailwind CSS (スタイリング用) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js (3D宇宙空間用) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        /* カスタムフォントと基本設定 */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&family=Noto+Sans+JP:wght@300;400;700&display=swap');

        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            background-color: #000000;
            color: #ffffff;
            overflow-x: hidden;
            margin: 0;
        }

        /* スクロールバーのカスタマイズ */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #0f0f0f;
        }
        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* ヒーローセクションのキャンバス */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: -1; /* コンテンツの後ろに配置 */
        }

        /* ガラスモーフィズム効果 */
        .glass-panel {
            background: rgba(10, 10, 20, 0.6);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        /* カードのホバーエフェクト */
        .game-card {
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .game-card:hover {
            transform: translateY(-8px) scale(1.02);
            border-color: rgba(255, 100, 200, 0.5); /* ピンクに変更 */
            box-shadow: 0 20px 40px -10px rgba(255, 0, 200, 0.2);
        }

        /* スクロールダウンの矢印アニメーション */
        .scroll-indicator {
            animation: bounce 2s infinite;
        }
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {transform: translateY(0);}
            40% {transform: translateY(-10px);}
            60% {transform: translateY(-5px);}
        }

        /* ユーティリティ */
        .text-gradient {
            background: linear-gradient(to right, #ff99cc, #c4a0ff, #ffcc00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-size: 200% auto;
            animation: gradientMove 5s ease infinite;
        }
        @keyframes gradientMove {
            0% {background-position: 0% 50%;}
            50% {background-position: 100% 50%;}
            100% {background-position: 0% 50%;}
        }
        
        .cursor-pointer {
            cursor: pointer;
        }
    </style>
</head>
<body class="antialiased">

    <!-- 3D背景（宇宙空間） -->
    <div id="canvas-container"></div>

    <!-- コンテンツラッパー -->
    <div class="relative w-full min-h-screen flex flex-col">

        <!-- ヘッダー / ヒーローセクション -->
        <header class="h-screen flex flex-col justify-center items-center text-center px-4 relative">
            <div class="glass-panel p-8 md:p-12 rounded-2xl max-w-4xl animate-fade-in-up border-t border-white/10">
                <span class="inline-block py-1 px-3 rounded-full bg-purple-500/10 text-pink-300 text-xs font-semibold tracking-wider mb-4 border border-purple-500/20 shadow-[0_0_15px_rgba(236,72,153,0.3)]">
                    EDUCATIONAL ARCHIVE
                </span>
                <h1 class="text-4xl md:text-8xl font-black mb-6 tracking-tight drop-shadow-2xl">
                    <span class="text-gradient">Universe Guidebook</span>
                </h1>
                <p class="text-gray-300 text-lg md:text-xl max-w-2xl mx-auto mb-10 leading-relaxed font-light">
                    ゼロから学ぶ宇宙の仕組み。<br class="hidden md:block">太陽系から最新の宇宙論まで。
                </p>
                <!-- 修正: onclickでスクロールを実行するボタンに変更 -->
                <div onclick="scrollToProjects()" class="group inline-flex items-center gap-3 bg-white/10 hover:bg-white text-white hover:text-black px-10 py-4 rounded-full font-bold transition-all duration-300 border border-white/20 hover:shadow-[0_0_30px_rgba(255,150,255,0.4)] backdrop-blur-md cursor-pointer select-none">
                    実験を開始する
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="group-hover:translate-y-1 transition-transform"><path d="M12 5v14M19 12l-7 7-7-7"/></svg>
                </div>
            </div>

            <!-- スクロールインジケーター -->
            <!-- 修正: onclickでスクロールを実行 -->
            <div onclick="scrollToProjects()" class="absolute bottom-10 left-1/2 transform -translate-x-1/2 text-gray-400 text-sm flex flex-col items-center gap-2 opacity-70 hover:opacity-100 transition-opacity cursor-pointer">
                <span class="tracking-[0.2em] uppercase text-[10px]">Scroll to Explore</span>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="scroll-indicator"><path d="M7 13l5 5 5-5M7 6l5 5 5-5"/></svg>
            </div>
        </header>

        <!-- ゲーム（教材）一覧セクション -->
        <main id="projects" class="w-full max-w-7xl mx-auto px-4 py-20 relative z-10">
            <div class="flex items-center justify-between mb-12 border-b border-gray-800 pb-4">
                <h2 class="text-3xl font-bold text-white">Available Modules</h2>
                <div class="flex items-center gap-2">
                    <span class="relative flex h-3 w-3">
                      <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-pink-400 opacity-75"></span>
                      <span class="relative inline-flex rounded-full h-3 w-3 bg-pink-500"></span>
                    </span>
                    <span class="text-sm text-gray-400 font-mono">SYSTEM ONLINE</span>
                </div>
            </div>

            <!-- グリッドレイアウト -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">

                <!-- Neon Tetris -->
                <a href="https://studymaterial.rixon1213.workers.dev/" target="_blank" class="block group">
                    <article class="game-card glass-panel rounded-2xl overflow-hidden h-full flex flex-col bg-gray-900/40">
                        <!-- サムネイル (ネオンテトリス風SVG) -->
                        <div class="h-56 bg-black relative overflow-hidden group-hover:opacity-100 transition-opacity">
                            <div class="w-full h-full flex items-center justify-center bg-[radial-gradient(ellipse_at_center,_var(--tw-gradient-stops))] from-slate-900 via-black to-black">
                                <!-- 発光するテトリスのSVGイメージ -->
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="w-full h-full p-6 transition-transform duration-700 group-hover:scale-110">
                                    <defs>
                                        <filter id="neon-glow" x="-50%" y="-50%" width="200%" height="200%">
                                            <feGaussianBlur stdDeviation="1.5" result="coloredBlur"/>
                                            <feMerge>
                                                <feMergeNode in="coloredBlur"/>
                                                <feMergeNode in="coloredBlur"/>
                                                <feMergeNode in="SourceGraphic"/>
                                            </feMerge>
                                        </filter>
                                    </defs>
                                    
                                    <!-- 背景グリッド -->
                                    <pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse">
                                        <path d="M 10 0 L 0 0 0 10" fill="none" stroke="rgba(255,255,255,0.05)" stroke-width="0.5"/>
                                    </pattern>
                                    <rect width="100" height="100" fill="url(#grid)" />
                                
                                    <g filter="url(#neon-glow)">
                                        <!-- 積み上がったブロック -->
                                        <path d="M10 80 h20 v20 h-20 z" fill="rgba(6,182,212,0.1)" stroke="#06b6d4" stroke-width="1.5"/>
                                        <path d="M30 80 h20 v20 h-20 z" fill="rgba(168,85,247,0.1)" stroke="#a855f7" stroke-width="1.5"/>
                                        <path d="M50 80 h20 v20 h-20 z" fill="rgba(168,85,247,0.1)" stroke="#a855f7" stroke-width="1.5"/>
                                        <path d="M40 60 h20 v20 h-20 z" fill="rgba(168,85,247,0.1)" stroke="#a855f7" stroke-width="1.5"/>
                                        
                                        <!-- 落ちてくるブロック (Oミノ) - 少し回転させる演出 -->
                                        <g transform="rotate(5, 70, 20)">
                                            <rect x="60" y="10" width="20" height="20" fill="rgba(253,224,71,0.1)" stroke="#fde047" stroke-width="1.5"/>
                                            <rect x="80" y="10" width="20" height="20" fill="rgba(253,224,71,0.1)" stroke="#fde047" stroke-width="1.5"/>
                                            <rect x="60" y="30" width="20" height="20" fill="rgba(253,224,71,0.1)" stroke="#fde047" stroke-width="1.5"/>
                                            <rect x="80" y="30" width="20" height="20" fill="rgba(253,224,71,0.1)" stroke="#fde047" stroke-width="1.5"/>
                                        </g>
                                    </g>
                                </svg>
                            </div>
                            <div class="absolute top-3 right-3 bg-purple-500/20 backdrop-blur-md px-3 py-1 rounded-full text-[10px] font-bold tracking-widest border border-purple-400/30 text-purple-300 shadow-[0_0_10px_rgba(168,85,247,0.3)]">
                                NEW MODULE
                            </div>
                        </div>
                        
                        <div class="p-8 flex-1 flex flex-col border-t border-white/5">
                            <div class="flex items-center gap-2 mb-4">
                                <span class="px-2 py-1 rounded text-[10px] font-bold uppercase tracking-wider bg-purple-500/10 text-purple-300 border border-purple-500/20">Logic</span>
                                <span class="px-2 py-1 rounded text-[10px] font-bold uppercase tracking-wider bg-cyan-500/10 text-cyan-300 border border-cyan-500/20">Spatial</span>
                            </div>
                            <h3 class="text-2xl font-bold mb-3 text-white group-hover:text-pink-400 transition-colors tracking-tight">Neon Tetris</h3>
                            <p class="text-gray-400 text-sm leading-relaxed mb-6 flex-1 font-light">
                                空間認識能力と論理的思考を養う、古典的な落下型パズルシミュレーション。瞬時の判断力とパターン認識を強化します。
                            </p>
                            <div class="flex items-center text-sm font-bold text-pink-400 mt-auto group-hover:text-pink-300">
                                ACCESS SIMULATION <span class="ml-2 group-hover:translate-x-2 transition-transform duration-300">→</span>
                            </div>
                        </div>
                    </article>
                </a>

            </div>
        </main>

        <!-- フッター -->
        <footer class="mt-auto py-12 text-center text-gray-600 text-xs relative z-10 border-t border-white/5 bg-black/50 backdrop-blur-md">
            <p class="mb-2 tracking-widest">&copy; 2024 Universe Guidebook Project.</p>
            <p class="opacity-40">System Architecture v4.2.0 | High-Resolution Rendering Enabled</p>
        </footer>
    </div>

    <!-- スクロール制御用スクリプト -->
    <script>
        function scrollToProjects() {
            const projectsSection = document.getElementById('projects');
            if (projectsSection) {
                projectsSection.scrollIntoView({ behavior: 'smooth' });
            }
        }
    </script>

    <!-- Three.js アニメーションスクリプト -->
    <script>
        // 1. シーンのセットアップ
        const scene = new THREE.Scene();
        // 霧を追加して奥行き感を出す（宇宙の深淵）
        scene.fog = new THREE.FogExp2(0x0a0514, 0.0008); 

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        
        const renderer = new THREE.WebGLRenderer({ alpha: false, antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0)); 
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- 銀河・星空の生成 ---
        function createStarField() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsCount = 15000; 
            
            const posArray = new Float32Array(starsCount * 3);
            const sizeArray = new Float32Array(starsCount);
            const colorArray = new Float32Array(starsCount * 3);
            
            for(let i = 0; i < starsCount * 3; i+=3) {
                const r = 400 + Math.random() * 1000; 
                const theta = 2 * Math.PI * Math.random();
                const phi = Math.acos(2 * Math.random() - 1);
                
                posArray[i] = r * Math.sin(phi) * Math.cos(theta);
                posArray[i+1] = r * Math.sin(phi) * Math.sin(theta);
                posArray[i+2] = r * Math.cos(phi);
                
                sizeArray[i/3] = Math.random() * 1.5;

                const starColorType = Math.random();
                if (starColorType > 0.9) { // ピンク
                    colorArray[i] = 1.0; colorArray[i+1] = 0.5; colorArray[i+2] = 0.8;
                } else if (starColorType > 0.8) { // 青
                    colorArray[i] = 0.5; colorArray[i+1] = 0.8; colorArray[i+2] = 1.0;
                } else { // 白
                    colorArray[i] = 1.0; colorArray[i+1] = 1.0; colorArray[i+2] = 1.0;
                }
            }
            
            starsGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            starsGeometry.setAttribute('size', new THREE.BufferAttribute(sizeArray, 1));
            starsGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
            
            const starsMaterial = new THREE.PointsMaterial({
                size: 0.8,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            const starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);
            return starField;
        }
        
        const starField = createStarField();

        // --- テクスチャ生成関数 ---
        function createFantasySaturnTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0.00, '#1a0b2e'); 
            gradient.addColorStop(0.15, '#4b0082'); 
            gradient.addColorStop(0.35, '#ff00cc'); 
            gradient.addColorStop(0.48, '#ffd700'); 
            gradient.addColorStop(0.52, '#ffffff'); 
            gradient.addColorStop(0.56, '#ffd700'); 
            gradient.addColorStop(0.65, '#ff66b2'); 
            gradient.addColorStop(0.85, '#6441a5'); 
            gradient.addColorStop(1.00, '#1a0b2e'); 

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1024, 512);

            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * 1024;
                const y = Math.random() * 512;
                const size = Math.random() * 2;
                
                const rand = Math.random();
                if (rand > 0.7) ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
                else if (rand > 0.4) ctx.fillStyle = "rgba(0, 255, 255, 0.4)";
                else ctx.fillStyle = "rgba(255, 105, 180, 0.4)";
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            for(let i=0; i<20; i++) {
                const y = Math.random() * 512;
                const h = Math.random() * 20 + 5;
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.1})`;
                ctx.fillRect(0, y, 1024, h);
            }

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- コメット（彗星）のテクスチャ生成 ---
        function createCometTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // 中心から発光するグラデーション
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); // 中心: 白
            gradient.addColorStop(0.2, 'rgba(200, 240, 255, 0.8)'); // 内側: 青白
            gradient.addColorStop(0.5, 'rgba(100, 150, 255, 0.3)'); // 外側: 青
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // フチ: 透明
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            return new THREE.CanvasTexture(canvas);
        }

        // --- 土星本体の生成 ---
        const saturnGeometry = new THREE.SphereGeometry(10, 128, 128); 
        const fantasyTexture = createFantasySaturnTexture();
        const saturnMaterial = new THREE.MeshPhysicalMaterial({
            map: fantasyTexture,
            color: 0xffffff,
            roughness: 0.2,   
            metalness: 0.1,   
            emissive: 0x440022, 
            emissiveMap: fantasyTexture, 
            emissiveIntensity: 0.3, 
            clearcoat: 0.5, 
            clearcoatRoughness: 0.1
        });
        const saturnMesh = new THREE.Mesh(saturnGeometry, saturnMaterial);
        
        const tilt = Math.PI * 0.15;
        saturnMesh.rotation.z = tilt;
        saturnMesh.rotation.x = Math.PI * 0.1;
        
        scene.add(saturnMesh);

        // --- 土星の輪 ---
        const asteroidGeometry = new THREE.DodecahedronGeometry(0.2, 0); 
        const asteroidMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xd8bfd8, 
            roughness: 0.4,
            metalness: 0.5,
            flatShading: true 
        });

        const count = 8000;
        const mesh = new THREE.InstancedMesh(asteroidGeometry, asteroidMaterial, count);
        
        const dummy = new THREE.Object3D();
        const color = new THREE.Color();
        
        for (let i = 0; i < count; i++) {
            const radius = 23 + Math.random() * 21; 
            const angle = Math.random() * Math.PI * 2;
            const spreadY = (Math.random() - 0.5) * (0.5 + (radius - 23) * 0.05);

            dummy.position.set(
                Math.cos(angle) * radius,
                spreadY,
                Math.sin(angle) * radius
            );

            dummy.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );

            const scale = Math.random() * 0.8 + 0.2;
            dummy.scale.set(scale, scale, scale);

            dummy.updateMatrix();
            mesh.setMatrixAt(i, dummy.matrix);
            
            const colorRandom = Math.random();
            if (colorRandom > 0.7) {
                color.setHSL(0.9, 0.8, 0.7 + Math.random() * 0.2); 
            } else if (colorRandom > 0.4) {
                color.setHSL(0.8, 0.6, 0.6 + Math.random() * 0.2);
            } else {
                color.setHSL(0.6, 0.5, 0.8 + Math.random() * 0.2);
            }
            mesh.setColorAt(i, color);
        }
        
        mesh.rotation.z = tilt;
        mesh.rotation.x = Math.PI * 0.1;
        
        scene.add(mesh);

        // --- ライティング ---
        const ambientLight = new THREE.AmbientLight(0x221133); 
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffeebb, 1.5);
        sunLight.position.set(100, 30, 50);
        scene.add(sunLight);
        
        const rimLight = new THREE.SpotLight(0xff00ff, 2.0);
        rimLight.position.set(-50, 10, -20);
        rimLight.lookAt(0, 0, 0);
        scene.add(rimLight);


        // --- 流れ星システム ---
        const shootingStars = [];
        const shootingStarGeometry = new THREE.BufferGeometry();
        const linePoints = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 10)];
        shootingStarGeometry.setFromPoints(linePoints);
        const shootingStarMaterial = new THREE.LineBasicMaterial({ color: 0xaaddff, transparent: true, opacity: 0 });

        function createShootingStar() {
            const star = new THREE.Line(shootingStarGeometry, shootingStarMaterial.clone());
            const startX = (Math.random() - 0.5) * 400;
            const startY = (Math.random() - 0.5) * 200 + 50;
            const startZ = (Math.random() - 0.5) * 100 - 100;
            
            star.position.set(startX, startY, startZ);
            star.rotation.x = Math.random() * Math.PI;
            star.rotation.y = Math.random() * Math.PI;
            
            star.userData = {
                speed: 2 + Math.random() * 3,
                life: 1.0,
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 5, 
                    -(Math.random() * 2 + 1), 
                    (Math.random() - 0.5) * 5
                ).normalize()
            };
            
            scene.add(star);
            shootingStars.push(star);
        }

        // --- 彗星（コメット）システム ---
        // 一際輝く大きな星
        let comet = null;
        const cometTexture = createCometTexture();
        const cometMaterial = new THREE.SpriteMaterial({ 
            map: cometTexture, 
            color: 0x88ccff, 
            blending: THREE.AdditiveBlending,
            transparent: true
        });
        
        // 彗星の尾（トレイル）
        // 過去の位置を記録して線を描画する
        const MAX_TRAIL_POINTS = 50;
        const trailGeometry = new THREE.BufferGeometry();
        // 頂点バッファを初期化
        const trailPositions = new Float32Array(MAX_TRAIL_POINTS * 3);
        trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
        const trailMaterial = new THREE.LineBasicMaterial({ 
            color: 0x44aaff, 
            transparent: true, 
            opacity: 0.6,
            linewidth: 2 
        });
        const cometTrail = new THREE.Line(trailGeometry, trailMaterial);

        function spawnComet() {
            if (comet) return; // 既に存在する場合は生成しない

            const sprite = new THREE.Sprite(cometMaterial);
            // サイズを大きく
            sprite.scale.set(8, 8, 1);
            
            // 画面外からスタート
            const startX = -200;
            const startY = 100;
            const startZ = -100;

            sprite.position.set(startX, startY, startZ);
            
            // ゆっくり横切る
            sprite.userData = {
                velocity: new THREE.Vector3(1.5, -0.5, 0.5),
                life: 600, // 長生き
                history: []
            };

            comet = sprite;
            scene.add(comet);
            scene.add(cometTrail);
            
            // トレイルの初期化
            for(let i=0; i<MAX_TRAIL_POINTS; i++) {
                cometTrail.geometry.attributes.position.setXYZ(i, startX, startY, startZ);
            }
        }

        function updateComet() {
            if (!comet) return;

            // 移動
            comet.position.add(comet.userData.velocity);
            
            // 履歴の更新（尾を描画するため）
            const history = comet.userData.history;
            history.unshift(comet.position.clone());
            if (history.length > MAX_TRAIL_POINTS) {
                history.pop();
            }

            // トレイルの頂点更新
            const positions = cometTrail.geometry.attributes.position.array;
            for(let i=0; i<history.length; i++) {
                positions[i*3] = history[i].x;
                positions[i*3+1] = history[i].y;
                positions[i*3+2] = history[i].z;
            }
            // 履歴が足りない分は最後の位置で埋める
            if (history.length > 0) {
                const lastPos = history[history.length-1];
                for(let i=history.length; i<MAX_TRAIL_POINTS; i++) {
                    positions[i*3] = lastPos.x;
                    positions[i*3+1] = lastPos.y;
                    positions[i*3+2] = lastPos.z;
                }
            }
            cometTrail.geometry.attributes.position.needsUpdate = true;

            // 寿命チェック
            comet.userData.life--;
            if (comet.userData.life <= 0 || comet.position.x > 300) {
                scene.remove(comet);
                scene.remove(cometTrail);
                comet = null;
            }
        }


        // カメラ設定
        camera.position.set(40, 10, 40);
        camera.lookAt(0, 0, 0);

        // --- アニメーションループ ---
        let time = 0;
        let starSpawnTimer = 0;
        let cometSpawnTimer = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.0005;

            // 土星の自転
            saturnMesh.rotation.y += 0.0005;

            // 輪の回転
            mesh.rotation.y = time * 0.5;

            // 背景の星空もわずかに回転
            starField.rotation.y = time * 0.05;

            // カメラワーク
            const camRadius = 45;
            const camSpeed = 0.1;
            camera.position.x = Math.sin(time * camSpeed) * camRadius;
            camera.position.z = Math.cos(time * camSpeed) * camRadius;
            camera.lookAt(0, 0, 0);

            // 流れ星 (高頻度)
            starSpawnTimer++;
            if (starSpawnTimer > 15) { 
                createShootingStar();
                starSpawnTimer = 0;
            }
            
            // 彗星 (低頻度 - 約10秒に1回チャンス)
            cometSpawnTimer++;
            if (cometSpawnTimer > 600) {
                if (Math.random() > 0.5) spawnComet(); // 確率で生成
                cometSpawnTimer = 0;
            }
            updateComet(); // 彗星の更新
            
            // 流れ星の更新
            for (let i = shootingStars.length - 1; i >= 0; i--) {
                const star = shootingStars[i];
                const speed = star.userData.speed;
                const vel = star.userData.velocity;
                
                star.position.x += vel.x * speed;
                star.position.y += vel.y * speed;
                star.position.z += vel.z * speed;
                star.userData.life -= 0.015;
                
                let opacity = 0;
                if (star.userData.life > 0.8) opacity = (1 - star.userData.life) * 5;
                else opacity = star.userData.life;
                star.material.opacity = opacity;
                
                if (star.userData.life <= 0) {
                    scene.remove(star);
                    shootingStars.splice(i, 1);
                    star.geometry.dispose();
                    star.material.dispose();
                }
            }

            renderer.render(scene, camera);
        }

        animate();

        // リサイズ対応
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
